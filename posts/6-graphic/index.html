<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>뷰에 원하는 모양을 그려보자. | 준모의 개발 노트</title><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#ff3db4><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://jmpark6846.github.io/css/main.min.e34415025514319010e741089e6920454053855755ba465f66943ad102d2cb08.css></head><body><nav><header><div class=site-title><a href=/>준모의 개발 노트</a></div></header><div class=nav-menu><a class="color-link nav-link" href=https://jmpark6846.github.io/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://jmpark6846.github.io/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>뷰에 원하는 모양을 그려보자.</h1><time>January 21, 2023</time><div><p><p>Quartz 쿼츠는 iOS, Mac 운영체제에서 사용하는 그래픽 엔진이다.<br>쿼츠가 실제 그래픽을 뷰에 그릴때 Graphic Context를 가지고 그린다. 컨텍스트엔 색상, 크기 같은 정보와 디바이스에 관련된 정보들이 담겨있다. 여기서 디바이스란 pdf, bitmap, printer, layer 등을 의미한다.</p><h3 id=그래픽-컨텍스트를-뷰에-그리기>그래픽 컨텍스트를 뷰에 그리기</h3><ul><li>ios 앱의 스크린에 뷰를 그리려면 먼저 UIView 객체를 만들고 그리기를 수행하는 <code>draw(rect:)</code> 메소드를 구현해야한다.</li><li><code>draw(rect:)</code> 메소드는 뷰가 화면에 보일때와 그 내용이 업데이트가 필요할때 호출된다.</li><li>구현한 <code>draw(rect:)</code> 메소드가 호출되기 전에, 뷰 객체는 자동으로 필요한 환경을 구성한다. 이때 뷰 객체는 현재 환경에 맞는 그래픽 컨텍스트를 생성한다.</li></ul><p>아래는 컨텍스트를 이용해 원을 그리는 코드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>draw</span>(<span style=color:#66d9ef>_</span> rect: CGRect) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> context = UIGraphicsGetCurrentContext() <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    context.beginPath()
</span></span><span style=display:flex><span>    context.setLineWidth(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>    context.setStrokeColor(UIColor.white.cgColor)
</span></span><span style=display:flex><span>    context.addArc(center: <span style=color:#66d9ef>self</span>.center, radius: <span style=color:#ae81ff>30</span>, startAngle: <span style=color:#ae81ff>0</span>, endAngle: <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> .pi, clockwise: <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>    context.strokePath()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=만약-애니메이션을-그리고-싶다면-어떻게-될까>만약 애니메이션을 그리고 싶다면 어떻게 될까?</h2><p>뷰의 draw 메소드를 반복적으로 호출해서 UI에 변화를 줄 수 있겠지만 이런 방법은 자원을 많이 사용하는 비싼 방법이다. 왜냐하면 바쁜 메인 스레드에서 동작하기 때문. 그럴땐 애니메이션을 그릴 수 있는 <em>CoreAnimation</em> 코어 애니메이션을 사용한다.</p><p>코어 애니메이션은 뷰가 아닌 레이어를 사용해서 그림을 그린다. 레이어는 뷰를 직접 그리지 않고, 현재의 뷰의 인터페이스를 가져와서 비트맵 형태로 관리만 한다. 그럼 이 비트맵 정보를 하드웨어가 그린다. 그렇기 때문에 메인스레드에서 하는 뷰의 그리기 작업보다 훨씬 빠른 것이다.</p><p>레이어를 그리면 실제 레이어의 구조를 그대로 가져와서 Presentation 레이어를 만들고 실제로는 Presentation 레이어를 화면에 보여준다. 따라서 에니메이션의 current value를 얻고 싶으면 presentation 레이어를 참고해야한다.</p><p>원형프로그래스바를 만들기 위해 뷰의 레이어에 서브레이어를 추가하는 코드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> progressBarLayer = CAShapeLayer()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>progressBarLayer.strokeColor = progressTintColor
</span></span><span style=display:flex><span>progressBarLayer.fillColor = UIColor.clear.cgColor
</span></span><span style=display:flex><span>progressBarLayer.lineWidth = lineWidth
</span></span><span style=display:flex><span>progressBarLayer.lineCap = .round
</span></span><span style=display:flex><span>progressBarLayer.lineJoin = .round
</span></span><span style=display:flex><span>layer.addSublayer(progressBarLayer)
</span></span></code></pre></div><p>그리고 그림을 그릴 패스를 추가하고 위치를 설정했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>layoutSubviews</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.layoutSubviews()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> path = UIBezierPath(arcCenter: .zero, radius: radius, startAngle: CGFloat(<span style=color:#f92672>-</span><span style=color:#ae81ff>90</span>).radian(), endAngle: CGFloat(<span style=color:#ae81ff>270</span>).radian(), clockwise: <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> center = CGPoint(x: bounds.midX, y: bounds.midY)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    progressBarLayer.path = path.cgPath
</span></span><span style=display:flex><span>    progressBarLayer.position = center
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이렇게 추가해주면 레이어의 정보들을 따라 그림을 그린다. 여기에 에니메이션을 만들어서 추가해주면 <code>add</code>하는 즉시 실행된다. 애니메이션하고 싶은 레이어의 속성을 키로 지정하여 객체를 생성한뒤 지속 시간이나 보여줄 값을 지정하는 방식이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> animation = CABasicAnimation(keyPath: <span style=color:#e6db74>&#34;strokeStart&#34;</span>)
</span></span><span style=display:flex><span>animation.duration = duration
</span></span><span style=display:flex><span>animation.fromValue = strokeStart
</span></span><span style=display:flex><span>animation.toValue = <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>animation.delegate = <span style=color:#66d9ef>self</span>
</span></span><span style=display:flex><span>animation.isRemovedOnCompletion = <span style=color:#66d9ef>false</span> 
</span></span><span style=display:flex><span>progressBarLayer.add(animation, forKey: <span style=color:#e6db74>&#34;strokeStart&#34;</span>)
</span></span></code></pre></div><p>애니메이션이 시작하거나 끝났을때 이벤트를 처리하고 싶다면 CAAnimationDelegate를 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>CircularPrograssBar</span>: CAAnimationDelegate {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>animationDidStop</span>(<span style=color:#66d9ef>_</span> anim: CAAnimation, finished flag: Bool) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> flag {
</span></span><span style=display:flex><span>            progressBarLayer.strokeStart = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위에 언급한 대로 presentation 레이어로 에니메이션의 현재 값을 얻어올 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getPresentationStrokeStart</span>() -&gt; CGFloat? {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> progressBarLayer.presentation()?.strokeStart
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>애니메이션은 실제 동영상을 플레이하는 것과 비슷하게 속도나 시작시간 같은 속성들이 있다. 이것을 조절하면 애니메이션을 일시정지시키거나 다시 재개시킬 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pause</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pausedTime : CFTimeInterval = <span style=color:#66d9ef>self</span>.convertTime(CACurrentMediaTime(), from: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.speed = <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.timeOffset = pausedTime
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>resume</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pausedTime = <span style=color:#66d9ef>self</span>.timeOffset
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.speed = <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.timeOffset = <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.beginTime = <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> timeSincePause = <span style=color:#66d9ef>self</span>.convertTime(CACurrentMediaTime(), from: <span style=color:#66d9ef>nil</span>) <span style=color:#f92672>-</span> pausedTime
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.beginTime = timeSincePause
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>아래는 플레이그라운드에서 간단히 만들어본 예제이다.</p><p>먼저 레이어에 흰색 원 테두리를 그려보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>UIKit</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>PlaygroundSupport</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> view = UIView()
</span></span><span style=display:flex><span>view.frame = CGRect(x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span>, width: <span style=color:#ae81ff>300</span>, height: <span style=color:#ae81ff>300</span>)
</span></span><span style=display:flex><span>view.backgroundColor = .systemMint
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> layer = CAShapeLayer()
</span></span><span style=display:flex><span>layer.strokeColor = UIColor.white.cgColor
</span></span><span style=display:flex><span>layer.fillColor = UIColor.clear.cgColor
</span></span><span style=display:flex><span>layer.lineWidth = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>layer.lineCap = .round
</span></span><span style=display:flex><span>layer.lineJoin = .round
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> path = UIBezierPath(arcCenter: .zero, radius: <span style=color:#ae81ff>60</span>, startAngle: <span style=color:#ae81ff>0</span>, endAngle: <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> .pi, clockwise: <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> center = CGPoint(x: view.frame.midX, y: view.frame.midY)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>layer.path = path.cgPath
</span></span><span style=display:flex><span>layer.position = center
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> progressBar = UIView()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>progressBar.layer.addSublayer(layer)
</span></span><span style=display:flex><span>view.addSubview(progressBar)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PlaygroundPage.current.liveView = view
</span></span></code></pre></div><p><img src=/image/6-1.png alt=원></p><p>그 다음 레이어에 애니메이션을 추가하면 프로그래스바 처럼 움직인다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> animation = CABasicAnimation(keyPath: <span style=color:#e6db74>&#34;strokeStart&#34;</span>)
</span></span><span style=display:flex><span>animation.duration = <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>animation.fromValue = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>animation.toValue = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>animation.repeatCount = .greatestFiniteMagnitude
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>layer.add(animation, forKey: <span style=color:#e6db74>&#34;animation&#34;</span>)
</span></span></code></pre></div><p><img src=/image/6-2.gif alt=원></p><p>참고</p><ol><li><a href=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514-CH1-SW1>Core Animation Programming Guide</a></li></ol></p></div><div class=page-footer><hr class=footer-divider><a class=tag href=/tags/ios>#ios</a>
<a class=tag href=/tags/app>#app</a></div></div><footer class=footer-mobile><div class=social-icons></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://jmpark6846.github.io/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></body></html>