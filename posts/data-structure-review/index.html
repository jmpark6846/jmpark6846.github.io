<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>자료구조 간단 정리 | 준모의 개발 노트</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="자료구조 간단 정리 Array 여러개의 데이터를 저장할 수 있는 자료형 선언할 때 고정된 크기로 선언한다. 이후에 변경할 수 없다. 인덱스로 데이터에 접근하면 O(1)이다. List 배열과 마찬가지로 여러개의 데이터를 저장할 수 있으나 크기가 고정되지 않아 자유롭게 추가하거나 삭제할 수 있다. 대표적으로 ArrayList와 LinkedList가 있다. 둘은 논리적, 물리적 저장 순서가 일치하느냐의 차이이다. ArrayList 논리적, 물리적 저장순서가 일치한다. 즉 일반 배열 처럼 데이터가 메모리상에 인접하여 저장된다. 인덱스로 데이터에 접근하면 O(1)이다. 삽입, 삭제 시 기존 원소들을 삽입, 삭제된 원소 갯수 만큼 이동시켜야하므로 O(n)의 시간이 걸린다."><meta name=generator content="Hugo 0.109.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="자료구조 간단 정리"><meta property="og:description" content="자료구조 간단 정리 Array 여러개의 데이터를 저장할 수 있는 자료형 선언할 때 고정된 크기로 선언한다. 이후에 변경할 수 없다. 인덱스로 데이터에 접근하면 O(1)이다. List 배열과 마찬가지로 여러개의 데이터를 저장할 수 있으나 크기가 고정되지 않아 자유롭게 추가하거나 삭제할 수 있다. 대표적으로 ArrayList와 LinkedList가 있다. 둘은 논리적, 물리적 저장 순서가 일치하느냐의 차이이다. ArrayList 논리적, 물리적 저장순서가 일치한다. 즉 일반 배열 처럼 데이터가 메모리상에 인접하여 저장된다. 인덱스로 데이터에 접근하면 O(1)이다. 삽입, 삭제 시 기존 원소들을 삽입, 삭제된 원소 갯수 만큼 이동시켜야하므로 O(n)의 시간이 걸린다."><meta property="og:type" content="article"><meta property="og:url" content="http://jmpark6846.github.io/posts/data-structure-review/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-24T15:59:31+09:00"><meta property="article:modified_time" content="2022-12-24T15:59:31+09:00"><meta itemprop=name content="자료구조 간단 정리"><meta itemprop=description content="자료구조 간단 정리 Array 여러개의 데이터를 저장할 수 있는 자료형 선언할 때 고정된 크기로 선언한다. 이후에 변경할 수 없다. 인덱스로 데이터에 접근하면 O(1)이다. List 배열과 마찬가지로 여러개의 데이터를 저장할 수 있으나 크기가 고정되지 않아 자유롭게 추가하거나 삭제할 수 있다. 대표적으로 ArrayList와 LinkedList가 있다. 둘은 논리적, 물리적 저장 순서가 일치하느냐의 차이이다. ArrayList 논리적, 물리적 저장순서가 일치한다. 즉 일반 배열 처럼 데이터가 메모리상에 인접하여 저장된다. 인덱스로 데이터에 접근하면 O(1)이다. 삽입, 삭제 시 기존 원소들을 삽입, 삭제된 원소 갯수 만큼 이동시켜야하므로 O(n)의 시간이 걸린다."><meta itemprop=datePublished content="2022-12-24T15:59:31+09:00"><meta itemprop=dateModified content="2022-12-24T15:59:31+09:00"><meta itemprop=wordCount content="421"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="자료구조 간단 정리"><meta name=twitter:description content="자료구조 간단 정리 Array 여러개의 데이터를 저장할 수 있는 자료형 선언할 때 고정된 크기로 선언한다. 이후에 변경할 수 없다. 인덱스로 데이터에 접근하면 O(1)이다. List 배열과 마찬가지로 여러개의 데이터를 저장할 수 있으나 크기가 고정되지 않아 자유롭게 추가하거나 삭제할 수 있다. 대표적으로 ArrayList와 LinkedList가 있다. 둘은 논리적, 물리적 저장 순서가 일치하느냐의 차이이다. ArrayList 논리적, 물리적 저장순서가 일치한다. 즉 일반 배열 처럼 데이터가 메모리상에 인접하여 저장된다. 인덱스로 데이터에 접근하면 O(1)이다. 삽입, 삭제 시 기존 원소들을 삽입, 삭제된 원소 갯수 만큼 이동시켜야하므로 O(n)의 시간이 걸린다."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">준모의 개발 노트</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">자료구조 간단 정리</h1><time class="f6 mv4 dib tracked" datetime=2022-12-24T15:59:31+09:00>December 24, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=자료구조-간단-정리>자료구조 간단 정리</h1><h3 id=array>Array</h3><ul><li>여러개의 데이터를 저장할 수 있는 자료형</li><li>선언할 때 고정된 크기로 선언한다. 이후에 변경할 수 없다.</li><li>인덱스로 데이터에 접근하면 O(1)이다.</li></ul><h3 id=list>List</h3><ul><li>배열과 마찬가지로 여러개의 데이터를 저장할 수 있으나 크기가 고정되지 않아 자유롭게 추가하거나 삭제할 수 있다.</li><li>대표적으로 ArrayList와 LinkedList가 있다.</li><li>둘은 논리적, 물리적 저장 순서가 일치하느냐의 차이이다.</li></ul><h3 id=arraylist>ArrayList</h3><ul><li>논리적, 물리적 저장순서가 일치한다.</li><li>즉 일반 배열 처럼 데이터가 메모리상에 인접하여 저장된다.</li><li>인덱스로 데이터에 접근하면 O(1)이다.</li><li>삽입, 삭제 시 기존 원소들을 삽입, 삭제된 원소 갯수 만큼 이동시켜야하므로 O(n)의 시간이 걸린다.</li></ul><h3 id=linkedlist>LinkedList</h3><ul><li>논리적, 물리적 저장 순서가 일치하지 않는다.</li><li>즉 개념상으로는 데이터가 연결되서 저장되어있지만 실제로는 메모리 상에 랜덤한 위치에 있으며, 원소가 다음 저장위치를 가리키는 주소를 가지고 있다.</li><li>데이터를 처음 노드 부터 찾아야 하므로 접근 속도가 O(n)이다.</li><li>삽입 삭제도 O(n)이다.<ul><li>삽입, 삭제 자체는 다음 노드를 가리키는 주소만 변경하면 되기 때문에 O(1)이지만 삽입할 위치, 삭제할 노드를 찾으려면 O(n)이 걸리므로 결국 O(n)이다.</li></ul></li></ul><h3 id=stack>Stack</h3><ul><li>후입선출(LIFO): 나중에 입력된 데이터가 먼저 출력된다.</li></ul><h3 id=queue>Queue</h3><ul><li>선입선출(FIFO): 먼저 입력된 데이터가 먼저 출력된다.</li></ul><h3 id=tree>Tree</h3><ul><li>노드(Node)와 간선(Edge)으로 이루어진 자료구조.</li><li>계층적인 형태로 표현할 때 사용한다. 즉 사이클이 없다.</li><li>검색, 최대최소값, 우선순위 등을 구현할때 사용한다.</li><li>노드를 순회하는 방식은 크게 세 가지 전위, 중위, 후위 순회가 있다.</li><li>트리의 종류</li></ul><h3 id=binary-tree>Binary Tree</h3><ul><li>자식 노드를 최고 두 개까지 갖는 트리</li></ul><h3 id=complete-binary-tree>Complete Binary Tree</h3><ul><li>마지막 레벨을 제외하고, 모두 자식 노드의 갯수가 두 개인 트리.</li><li>마지막 레벨은 모두 채워질 필요는 없으나 왼쪽에서 오른쪽으로 채워져 있어야 한다.</li></ul><h3 id=binary-search-tree>Binary Search Tree</h3><ul><li>부모와 자식의 데이터의 크기가 다음 규칙을 만족하는 트리이다.</li><li>왼쪽 자식 &lt; 부모 &lt; 오른쪽 자식</li><li>원하는 데이터를 탐색하는 데 트리의 높이(h)만큼의 O(h)가 소요된다.</li><li>균등하게 데이터가 들어간다면 O(log(n))이지만 편향된 트리라면 O(n)으로 일반 리스트와 같아진다.</li><li>편향된 트리를 개선하기 위해 AVL 트리, Red Black 트리가 있다.</li></ul><h3 id=heap>Heap</h3><ul><li>완전 이진 트리의 한 종류.</li><li>최대값과 최소값을 빠르게 찾는 데 사용한다.</li><li>부모 노드의 값이 자식 노드의 값 보다 크면 최대힙, 작으면 최소힙이라고 한다.</li><li>즉 루트 노드가 최대값이거나 최소값이 된다. 따라서 최대값(최소값) 탐색은 O(1)</li></ul><h3 id=priority-queue>Priority Queue</h3><ul><li>우선순위 큐: 큐에 pop을 하면 먼저 들어온 순서부터 나오지만, 우선순위 큐는 우선순위가 높은 데이터가 출력된다.</li><li>힙으로 구현한다.</li></ul><h3 id=b-tree>B-Tree</h3><ul><li>이진 트리를 개선하여 탐색 성능을 높인 트리.</li><li>균형있게 높이를 유지하는 Balanced Tree. 모든 leaf 노드가 같은 레벨로 유지되도록 자동으로 밸런스를 맞춘다.</li><li>항상 균형된 높이를 유지하므로 탐색 시간은 O(log(n))이다.</li><li>자식 노드 수가 2개 이상이며 노드의 키(데이터)가 1개 이상이다. 한 노드의 키들은 항상 정렬되어있다.</li></ul><h3 id=hash-table>Hash Table</h3><ul><li>키, 값 형식의 자료 구조. 키로 값에 O(1)의 빠르게 접근할 수 있는 구조이다.</li><li>해시 함수를 사용해서 인덱스를 구한다.</li><li>해시 함수로 구한 인덱스는 충돌, 즉 같은 값이 나올 수 있으며 이를 해결하기 위한 방법으로 두 가지가 있다.<ul><li>분리 연결볍(Seperate Chaining): 충돌난 주소에 리스트 형태로 값을 저장하는 방법</li><li>개방 주소법(Open Addressing): 해시 테이블 내 비어있는 주소가 나올때 까지 주소를 다시 구하는 방법</li></ul></li></ul><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://jmpark6846.github.io/>&copy; 준모의 개발 노트 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>