<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>RxSwift 간단 정리 | 준모의 개발노트</title><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#ff3db4><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://jmpark6846.github.io/css/main.min.e34415025514319010e741089e6920454053855755ba465f66943ad102d2cb08.css></head><body><nav><header><div class=site-title><a href=/>준모의 개발노트</a></div></header><div class=nav-menu><a class="color-link nav-link" href=https://jmpark6846.github.io/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://jmpark6846.github.io/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>RxSwift 간단 정리</h1><time>March 2, 2023</time><div><p><h3 id=rxswift란>RxSwift란</h3><ul><li>비동기로 생기는 데이터를 편하게 사용하기 위해 사용한다.</li><li>비동기로 생기는 데이터를 클로져를 Completion Handler로 받아서 호출해왔지만 사용하기가 불편하다.</li><li>클로져가 아닌 값으로 받아서 다루기 위해 만들어진 유틸리티이다.</li></ul><p>비동기로 처리된다는 건 나중에 처리된다는 것이다.</p><ul><li>&lsquo;나중에 생기는 데이터&rsquo;를 <code>Observable</code>, <code>Promise</code> 등 으로 부르고</li><li>&lsquo;나중에 생기면 실행&rsquo;할 작업을 명시하는 것을 <code>subscribe</code>, <code>then</code> 으로 부른다.</li></ul><h3 id=observable-실행과-종료>Observable 실행과 종료</h3><p><code>Observable</code>은 생성하는 것만으로는 실행되지 않고 <code>subscribe</code>해야 실행된다.<br>subscribe를 실행하면 크게 세 가지 이벤트가 실행된다.</p><ul><li>next: 데이터 전송</li><li>complete: 실행 완료</li><li>error:에러</li></ul><p>complete와 error 이벤트를 호출하거나 subscribe의 리턴타입인 Disposables를 이용해 dispose하면 실행이 종료된다. 실행이 종료되면 클로져가 사라진다.</p><p>클로져 내에서 self를 사용하더라도 complete, error 이벤트 혹은 dispose 호출하면 클로져가 사라져서 self에 대한 참조카운트가 감소한다. 따라서 순환참조 문제가 해결된다.</p><p>Observable이 subscribe 후 complete, error 혹은 dispose 되어 실행이 종료된다.
종료된 Observable은 후에 subscribe하거나 사용하더라도 다시 실행되지 않는다.</p><h3 id=처음-rxswift를-사용한다면-크게-두-가지를-신경쓰자>처음 RxSwift를 사용한다면 크게 두 가지를 신경쓰자.</h3><ol><li><p>비동기로 생기는 데이터를 Observable로 감싸서 리턴하는 방법</p><ol><li>Observable.create {} 속에서 비동기 처리를 실행</li><li>onNext(data)로 데이터 전달, onComplete, onError 실행</li><li>disposable 생성하여 리턴</li></ol></li><li><p>Observable로 오는 데이터를 받아서 처리하는 방법</p><ol><li>Observable에 subscribe하여 이벤트를 처리할 클로져를 넘긴다.</li><li>event에 맞는 처리</li><li>disposable을 disposeBag에 추가</li></ol></li></ol><h3 id=operator>Operator</h3><p>1번과 2번을 반복해서 사용하다보니 더 간편한 방법이 필요하다! 그래서 reactive 에서는 여러가지 <code>Operator</code>를 제공한다.</p><ul><li>간단한 생성 : <code>just</code>, <code>from</code></li><li>필터링 : <code>filter</code>, <code>take</code></li><li>데이터 변형 : <code>map</code>, <code>flatMap</code></li><li><code>subscribe(onNext)</code></li><li><code>subscribeOn</code>: 데이터를 받아오는 작업을 실행할 스케줄러 지정</li><li><code>observeOn</code>: 지정되는 데이터를 보낼 작업을 실행할 스케줄러 지정. 이후 추가되는 작업들에 적용.</li><li><code>combine</code>, <code>merge</code>, <code>zip</code></li><li><code>disposed</code>: 비동기작업을 클래스 변수 <code>DisposeBag</code>에 추가하면 해당 클래스가 종료될때 자동으로 dispose됨</li></ul><p>cf) 스케줄러는 작업큐의 래퍼 클래스</p><h2 id=역할-정리>역할 정리</h2><h3 id=observable>Observable</h3><ul><li>값을 전송하는 역할. 값을 전송만 하고 외부에서 데이터를 받지는 못한다.</li></ul><h3 id=observer>Observer</h3><ul><li>값을 전송받아 작업을 수행하는 역할</li></ul><h3 id=subject>Subject</h3><ul><li>값을 받기도 하고 전송하기도 하는 역할. 즉 <code>Observable</code>이자 <code>Observer</code></li><li><code>Observable</code>과 마찬가지로 <code>complete</code>, <code>error</code> 이벤트가 발생되거나 dispose되면 실행이 종료된다. 이게 의도된 설계이지만 실제로 사용해보면 문제가 될수있다.<ul><li>실수로 <code>onComplete</code>을 호출하거나 에러가 발생할 경우 <code>Subject</code>의 실행이 종료되어 더이상 사용할 수 없고, <code>Subject</code>를 사용하는 UI 역시 동작하지 않는다.</li><li>따라서 이런 문제를 해결하기 위해 사용하는 것이 <code>Relay</code></li></ul></li></ul><h3 id=relay>Relay</h3><ul><li><code>Subject</code>와 동일한데 <code>onComplete</code>, <code>onError</code>를 호출하지 않고 데이터를 전송만한다.</li></ul></p></div><div class=page-footer><hr class=footer-divider><a class=tag href=/tags/mvvm>#MVVM</a>
<a class=tag href=/tags/rxswift>#RxSwift</a>
<a class=tag href=/tags/ios>#ios</a></div></div><footer class=footer-mobile><div class=social-icons></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://jmpark6846.github.io/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></body></html>