<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>MVC, MVP 그리고 MVVM | 준모의 개발노트</title><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#ff3db4><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://jmpark6846.github.io/css/main.min.e34415025514319010e741089e6920454053855755ba465f66943ad102d2cb08.css></head><body><nav><header><div class=site-title><a href=/>준모의 개발노트</a></div></header><div class=nav-menu><a class="color-link nav-link" href=https://jmpark6846.github.io/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://jmpark6846.github.io/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>MVC, MVP 그리고 MVVM</h1><time>March 2, 2023</time><div><p><h2 id=mvc>MVC</h2><p><img src=/image/mvc.png alt=mvc></p><p>MVC의 경우 모델은 데이터를 나타내는 역할을 말한다. 이때 모델은 UIKit에 종속되지 않기 때문에 테스트 가능한 모델이다.</p><p>그러나 컨트롤러와 뷰는 UIKit에 종속되기 때문에 로직부분만 테스트하기가 어렵다. 특히 컨트롤러에는 로직과 화면을 그리는 뷰 관련 코드들이 함께 있기 때문에 조금만 개발해도 매우 커져서 유지보수와 테스트가 어려워진다.</p><p><strong>=> 컨트롤러의 역할을 제한하자. 입력받는 부분을 뷰로 넘기자. 해서 나온게 MVP</strong></p><h2 id=mvp>MVP</h2><p><img src=/image/mvp.png alt=mvc></p><p>컨트롤러를 모두 뷰로 옮긴다.
프리젠터는 뷰에 표시해야할 요소를 계산해서 뷰에게 지시한다.
데이터 처리와 같은 로직은 모두 프리젠터에게 맡긴다. 그래서 프리젠터가 테스트하기 쉽게 만든다.
뷰는 여전히 UIKi에 종속되기 때문에 테스트가 어렵다.</p><p>예를 들어 어떤 사용자의 액션이 들어오면 뷰는 프리젠터에게 이 액션에 대해 무엇을 표시해야 할지 물어본다. 프리젠터는 계산을 해서 뷰에게 데이터를 넘겨준다.</p><p>문제는 이론상 뷰와 프리젠터가 1:1 관계이다. 즉 다수의 뷰에는 다수의 프리젠터가 필요하다. 또한 프리젠터가 일일이 뷰에게 무엇을 그릴지 알려줘야하는 것이 번거롭다.</p><p><strong>=> 하나의 프리젠터가 다수의 뷰를 상대하게끔 만들자. 해서 나온게 MVVM</strong></p><h2 id=mvvm>MVVM</h2><p><img src=/image/mvvm.png alt=mvvm></p><p>차이점은 뷰모델이 뷰에게 무엇을 그릴지 따로 지시하지 않는다. 뷰가 뷰모델의 변화에 맞춰 알아서 다시 그린다.</p><p>즉 뷰는 사용자의 상호작용을 받아 뷰모델에게 알리고, 뷰모델에서 데이터를 가져와 화면에 그리는 역할
뷰모델은 상호작용 이벤트에 맞게 데이터를 업데이트하거나 데이터를 뷰에게 넘긴다.</p><p>MVVM의 구현 방법에는 몇가지가 있으나 RxSwift, RxJs 등 reactive programming을 사용한 방법이 가장 많이 쓰인다.</p></p></div><div class=page-footer><hr class=footer-divider><a class=tag href=/tags/mvc>#MVC</a>
<a class=tag href=/tags/mvp>#MVP</a>
<a class=tag href=/tags/mvvm>#MVVM</a>
<a class=tag href=/tags/ios>#ios</a></div></div><footer class=footer-mobile><div class=social-icons></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://jmpark6846.github.io/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></body></html>